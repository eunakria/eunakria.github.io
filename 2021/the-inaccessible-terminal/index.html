<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Eunakria – The inaccessible terminal</title><link rel=icon href=/favicon.svg type=image/svg><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&family=Inter:wght@400;600;800&display=swap" rel=stylesheet><meta name=author content="Linus Parker"><meta property=og:title content="The inaccessible terminal"><meta property=og:type content=article><meta property=og:image content=https://eunakria.github.io/banner.jpg><meta property=og:url content=https://eunakria.github.io//2021/the-inaccessible-terminal><meta property=og:site_name content=Eunakria><meta property=og:description content=" Accessibility (hereafter referred to as a11y) comes in many forms. It refers to accommodation for people with physical disabilities, people who struggle with understanding complex models, or even simply fully able people in environments or constraints that prevent them from using applications to their full capability."><meta property=og:locale content=en><link rel=stylesheet href=/main.css><script defer=defer src=/bundle.js></script><script async src=//gc.zgo.at/count.js data-goatcounter=https://eunakria.goatcounter.com/count></script></head><body><nav><a class=narrow href=/feed.xml title="Atom feed" aria-label="Atom feed"><svg class=feather><use href=/feather-sprite.svg#rss /></svg> </a><a href=/posts><svg class=feather><use href=/feather-sprite.svg#pen-tool /></svg> <span>Posts</span> </a><a href=/ class=sn><span>Eunakria</span></a> <a href=/projects><svg class=feather><use href=/feather-sprite.svg#briefcase /></svg> <span>Projects</span> </a><a href=javascript:void(0) class=narrow title="Switch theme" aria-label="Switch theme" id=theme-toggle><svg class=feather><use href=/feather-sprite.svg#moon /></svg></a></nav><div class=short-charge><div class=container><h1 class=page-title>The inaccessible terminal</h1><p class=post-head><span class=post-head-tag><svg class=feather><use href=/feather-sprite.svg#calendar /></svg> <span>Apr 16, 2021</span> </span><span class=post-head-tag><svg class=feather><use href=/feather-sprite.svg#clock /></svg> <span>Reading time: 9 min</span></span></p></div></div><div class=container><p>Accessibility (hereafter referred to as a11y) comes in many forms. It refers to accommodation for people with physical disabilities, people who struggle with understanding complex models, or even simply fully able people in environments or constraints that prevent them from using applications to their full capability.</p><p>It's a well-known fact at this point that the traditional UNIX-like terminal model (hereafter the shell) is notorious for committing a lot of sins on this aspect, and modern UI/UX designers generally see the shell as a keen example of what <em>not</em> to do. To quote <em>The Unix Hater's Handbook,</em> a humorous take on the bad design of UNIX from the early Macintosh era:</p><blockquote><svg class=quote><use href=/quote.svg#q></use></svg><p>Ken Thompson has an automobile which he helped design. Unlike most automobiles, it has neither speedometer, nor gas gauge, nor any of the other numerous idiot lights which plague the modern driver. Rather, if the driver makes a mistake, a giant “?” lights up in the center of the dashboard. “The experienced driver,” says Thompson, “will usually know what’s wrong.”</p></blockquote><p>UNIX was a product of its time. It was a set of building blocks, scripting tools that all tried their absolute best to stay out of the end user's way, in part because that gave the user more freedom to do what they want, and in part because a program that did too much was too <em>slow</em> to use.</p><p>The irony is that a lot of things that are today done the "UNIX way" – chains of <code>sed</code> scripts and imperative configuration files galore – are the slowest and clunkiest parts of modern computers. Linux computers that use shell script-based inits boot slower than those that use inits with their own daemon management. Terminal windows become slower to start with every program you install that has to load itself into the <code>$PATH</code>.</p><p>One thing remains, and that is the power of the shell. Well, not "the" shell itself, as it existed way back in the day, and modern users of the shell are eager to point that out. Modern users don't use the original Bourne shell; they may instead use <code>bash</code> or <code>zsh</code> or <code>fish</code>. They will set a flag for <code>ls</code> that allows it to use colors. They will use <code>perl -pe</code> whenever their complicated regex doesn't work with plain <code>sed -E</code>.</p><p>It's a testament to how insufficient these programs were, but maybe the fundamental principles still live? My take is that they didn't.</p><div id=table-of-contents><ol><li><a href=#discoverability>Discoverability</a><ol><li><a href=#designing-for-discoverability>Designing for discoverability</a></li></ol></li><li><a href=#footguns>Footguns</a></li><li><a href=#assistive-tech>Assistive tech</a></li><li><a href=#conclusion>Conclusion</a></li></ol></div><h2><a class=page-anchor id=discoverability></a>Discoverability</h2><p>The shell scares off new users, and most experienced folk write it off as being unwilling to step out of one's comfort zone. <em>"If only you had been willing to get used to something slightly different,"</em> they often ration, <em>"you could unlock such hidden potential!"</em> I believe this is nothing more than survivorship bias.</p><p>A common driving principle in modern software development is that the user should be confronted with the software's features, laid out cleanly in hierarchy, guiding the user to where they have to go rather than making the user search though manuals (paper, electronic or online) to find what they want to do. A common display of this is in the design pattern of the ribbon, pioneered by Microsoft in their Office 2007 suite.</p><p>When working with Office, looking for a given tool, the mind naturally gravitates to the tabs at the top of the ribbon first. <em>"What does the thing I want to do, have to do with? I want to change the page size, so it's probably in Layout."</em> So, you go there. Then, you scan the list of icons to see which one seems like it has to do with page size. You check the text caption under the ones that seem relevant, and then you know you've found the right button.</p><p>Modern versions of Office, and, in fact, modern versions of any program with especially good UX, have a search bar as well, so if you can't figure out where something is but know it by name, you can search for it by that name.</p><p>Now, let's see how the shell handles this:</p><pre><code><span class=green>euna@Anchor</span>:<span class=blue>~</span>$ <u class=blink> </u></code></pre><p>(The joke is that there's nothing here.)</p><p>The shell essentially gives you nothing to start off with. A lot of traditional UNIX programs are that way, and again, this is a product of its time. Back in the day, I/O was expensive – folks had teletypewriters as their chief method of interface with their computers, and they were mighty slow. This even extended to the text editor.</p><p>Oh, god, the text editor. <code>ed</code> is such a hilariously unintuitive program that even the shell die-hards will leap at a chance to bash it. The only error message it gives is a single <code>?</code>. It doesn't have any help section from within the program; it doesn't even tell you how to quit out of it.</p><p>When you understand what's going on, it's a lot like the <code>vi</code> command line without the actual visual display; in fact, the <code>vi</code> command line was modeled after <code>ed</code>. But, <code>ed</code> is the chiefest example of a shell program throwing you into the deep end.</p><h3><a class=page-anchor id=designing-for-discoverability></a>Designing for discoverability</h3><p>If the issue is that the shell isn't discoverable, how do we make it discoverable? Surely something about the text-based interface the shell is intertwined with makes it impossible to "discover". I don't believe that's the case, but a lot of my opinions would mandate a fundamental overhaul of the shell. I recognize that it's too late at this point. POSIX is a codified and ubiquitous standard, the shell is used in places you would never expect it and it's something of a rite of passage for sysadmins worldwide. Nonetheless, it's fun to philosophize.</p><p>The first complaint of mine is strange command names. A lot of commands are given short names so that they're easy to type, but the consequence of this is that they're unclear.</p><ul><li><p><code>ls</code>, the command to list the contents of a directory, stands for the first two consonants in <strong>l</strong>i<strong>s</strong>t.</p></li><li><p><code>rm</code>, the command to <strong>r</strong>e<strong>m</strong>ove a file, follows the same scheme of abbreviation.</p></li></ul><p>Some others are named after strange, complicated, or obscured names.</p><ul><li><p><code>awk</code> is a domain-specific language for text transformation in shell script, and it's <a href="https://en.wikipedia.org/w/index.php?title=AWK&oldid=1005866427#History">named after its creators</a>, Alfred <strong>A</strong>ho, Peter <strong>W</strong>einberg and Brian <strong>K</strong>erninghan.</p></li><li><p><code>grep</code> <a href="https://en.wikipedia.org/w/index.php?title=Grep&oldid=1017322849">stands for a mnemonic</a> in <code>ed</code>, <code>g/re/p</code>, or <strong>g</strong>lobally search for a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint. Once you know that, you can tell it's a tool to filter incoming text by regex.</p></li><li><p><code>dd</code> <a href="https://groups.google.com/g/comp.unix.misc/c/LbLTa00Jnvg?pli=1">stands for <strong>c</strong>opy and <strong>c</strong>onvert</a>, but since <code>cc</code> is already taken for <strong>C c</strong>ompiler and <code>cd</code> is already <strong>c</strong>hange <strong>d</strong>irectory, they had to improvise.</p></li></ul><p>The UNIX shell can be compared, to an extent, to Microsoft's modern, data structure driven, .NET powered alternative called PowerShell. Many first-time users of PowerShell mock it for its verbose <code>Verb-Noun</code> commands, with such ridiculous names as <code>Get-ChildItem</code> to list the contents of a directory. It has saner, shorter aliases such as <code>ls</code> for these unwieldy commands, though they sometimes conflict with brand names, as is the case with <code>wget</code>.</p><p>There's something nice that happens when you try to search for a command in PowerShell, because it's always named after what it does, in long form, so you can search for the command you want quite efficiently. If I want to find something that can tell me the hash of a file, I can start with <code>*hash</code> (note the wildcard) and press tab to autocomplete a few times. Then, I stumble upon <code>Get-FileHash</code>, which seems to do what I want.</p><p>This doesn't work universally, and it's a little strange that PowerShell puts what you want to do <em>with</em> the object you're working with before what the object type <em>is.</em> However, naming every command after what it does is a huge step forwards.</p><p>If I were to revise this further, I would envision an interface something like this:</p><pre><code><span class=red>$</span> <span class=yellow>whatis</span> cd
<b>cd</b> is an alias for <b>directory-change</b>.

<span class=red>$</span> <span class=yellow>help</span> cd
<b>directory-change [directory]</b>
  Changes the current directory and pushes it to the history.
  To return to the previous directory, use <b>directory-return</b>.
<b>Aliases:</b>
  cd

<span class=red>$</span> <span class=yellow>help</span> directory-return
<b>directory-return</b>
  Reads off the directory history and goes back the previous path.
<b>Aliases:</b>
  popd

<span class=red>$</span> <span class=yellow>cd</span> Desktop/

<span class=red>$</span> <u class=blink> </u></code></pre><p>In my opinion, the shell should be highly willing to explain parts of itself to the user, rather than confront them with everything at once. This is what I fail to see, and what I'm campaigning ought to be implemented here.</p><p>There are many other changes I would make – for example, I would make it possible to explore modules as a whole, that have to do with things like file management, system settings, disk and partition management, etc.; but the fundamental point is that it should be possible to find commands and explore the system.</p><h2><a class=page-anchor id=footguns></a>Footguns</h2><p>Footguns are a playful name for the metaphor of "shooting yourself in the foot". They're a term to refer to the unknown unknowns of learning a new program, the things that a new user really should watch out for, but won't be told about in advance. Oh, what a shame it would be if they accidentally delete or overwrite a super important file!</p><p>The shell is full of its little footguns, and this becomes more obvious once you start to use its capability to chain commands together in pipelines, or even write whole loops and structures to process data in bulk. Let's go over a few, as a nice little lightning round:</p><ol><li><p>The <code>$( )</code> operator, used to pass one command's output as an argument to another, by default "expands", which means it turns outputs with spaces into multiple arguments. This means that if you wrote something like this:</p><pre><code class=language-sh><span class=hljs-comment># Prints the string 'Hello, world!'</span>
<span class=hljs-function><span class=hljs-title>a</span></span> () {
	<span class=hljs-built_in>echo</span> <span class=hljs-string>'Hello, world!'</span>
}

<span class=hljs-comment># Prints each argument on a separate line.</span>
<span class=hljs-function><span class=hljs-title>b</span></span> () {
	idx=1
	<span class=hljs-keyword>for</span> el <span class=hljs-keyword>in</span> <span class=hljs-string>"<span class=hljs-variable>$@</span>"</span>; <span class=hljs-keyword>do</span>
		<span class=hljs-built_in>echo</span> <span class=hljs-string>"<span class=hljs-variable>$idx</span>: <span class=hljs-variable>$el</span>"</span>
		idx=$(( idx + <span class=hljs-number>1</span> ))
	<span class=hljs-keyword>done</span>
}

<span class=hljs-comment># Spot the bug :)</span>
b $(a)
</code></pre><p>You would not get the expected output,</p><pre><code>1: Hello, world!
</code></pre><p>But instead, this:</p><pre><code>1: Hello,
2: world!
</code></pre></li><li><p>The same thing goes for variables. This</p><pre><code class=language-sh>hello=<span class=hljs-string>'Hello, world!'</span>
b <span class=hljs-variable>$hello</span>
</code></pre><p>Also confusingly prints:</p><pre><code>1: Hello,
2: world!
</code></pre></li><li><p>Shell script keeps going when you hit an error! You have to explicitly disable this behavior with <code>set -e</code>, which causes any non-zero exit code to cause the program to terminate immediately.</p><pre><code class=language-sh><span class=hljs-comment># Supposed to print 'Hello, '</span>
<span class=hljs-function><span class=hljs-title>a</span></span> () {
	<span class=hljs-built_in>echo</span> -n <span class=hljs-string>'Hello, '</span>
}

<span class=hljs-comment># Supposed to cause an error</span>
<span class=hljs-function><span class=hljs-title>b</span></span> () {
	<span class=hljs-built_in>return</span> 1
}

<span class=hljs-comment># Supposed to print 'world!'</span>
<span class=hljs-function><span class=hljs-title>c</span></span> () {
	<span class=hljs-built_in>echo</span> <span class=hljs-string>'world!'</span>
}

a; b; c
</code></pre><p>Now, instead of the expected output <code>Hello,</code> followed by an error, we get the full string:</p><pre><code>Hello, world!
</code></pre></li><li><p>Speaking of which, conditionals are commands, and they're supposed to fail to indicate the condition is false. The thing is, they can also fail if the command encounters any other error. There is no simple way to guard against this.</p><p>The following is wrong:</p><pre><code class=language-sh><span class=hljs-keyword>if</span> grep -i <span class=hljs-string>'hello'</span> <span class=hljs-string>"<span class=hljs-variable>$file</span>"</span>; <span class=hljs-keyword>then</span>
	<span class=hljs-built_in>echo</span> <span class=hljs-string>"<span class=hljs-variable>$file</span> contains hello"</span>
<span class=hljs-keyword>else</span>
	<span class=hljs-built_in>echo</span> <span class=hljs-string>"<span class=hljs-variable>$file</span> does not contain hello"</span>
<span class=hljs-keyword>fi</span>
</code></pre><p>And the following is right:</p><pre><code class=language-sh>grep -i <span class=hljs-string>'hello'</span> <span class=hljs-string>"<span class=hljs-variable>$file</span>"</span>
success=$?
<span class=hljs-keyword>if</span> [[ <span class=hljs-variable>$success</span> -eq 0 ]]; <span class=hljs-keyword>then</span>
	<span class=hljs-built_in>echo</span> <span class=hljs-string>"<span class=hljs-variable>$file</span> contains hello"</span>
<span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> [[ <span class=hljs-variable>$success</span> -eq 1 ]]; <span class=hljs-keyword>then</span>
	<span class=hljs-built_in>echo</span> <span class=hljs-string>"<span class=hljs-variable>$file</span> does not contain hello"</span>
<span class=hljs-keyword>else</span>
	<span class=hljs-comment># Handle error</span>
<span class=hljs-keyword>fi</span>
</code></pre></li></ol><p>The answer here must be made plain and harsh. The shell should not have any of these complexities. It's intimidating, confusing, infuriating and leads to bug-filled code and frustration. The shell is also the scripting language for whenever a developer needs to tie together other applications. If it's so load-bearing, why does it have these irritating flaws?</p><p>The shell may be powerful, but that power is thwarted by the user having to remember all these little nuances to find their way around it. It isn't nearly as automatic as it hopes to be, and all its little flaws truly hold it back.</p><h2><a class=page-anchor id=assistive-tech></a>Assistive tech</h2><p>Oh, boy, this is the big one! The terminal is famously at odds with assistive technology. Technologies to mimic a graphical interface in the terminal are incredibly common, even permeating into the modern day under the laudatory remarks of how lightweight and yet powerful they are. However, many people fail to see the ultimate utter lack of polish these technologies have. The easiest way to do that is to simply show how well these programs cooperate with one of the most common assistive technologies, the humble screen reader.</p><p>Testing with a screen reader is an imperative part of my work as a web designer. If my app doesn't work with a screen reader, it's not good enough. That means that anyone who's blind, vision-impaired, motor-impaired, and many people who suffer from other conditions, <em>cannot</em> use my app.</p><p>Usually, I rock a fairly customized setup, complete with <code>zsh</code> with syntax highlighting, a heavily customized Neovim, etc.. but right now, we're going back to the basics. I'm using a fairly default Ubuntu setup right now. Plain <code>bash</code>, fairly uncustomized <code>vim</code>, unmodified <code>man</code> paged with <code>less</code>. Pay attention to what you hear. Notice how the screen reader can never tell what to read to you.</p><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 38.3712%;"><iframe src=https://streamable.com/o/l8p1pp style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" allowfullscreen="" scrolling=no allow=encrypted-media></iframe></div><p>This is the most unfortunate reality of the shell. It's fundamentally exclusionary, even ableist. A11y was never a huge concern back in the UNIX days, but now, the shell simply doesn't cut it for folks who need a helping hand. It's frustrating to work with if you can't <em>see</em> the terminal – which is a little ironic, because one of the things the shell is most lauded for is not having a graphical interface, only text.</p><p>This is also what upsets me the most about anything in the shell. Never mind the fact that it's hard to jump into, never mind having to remind yourself of all the little quirks it's accumulated over a history of poor decisions. The biggest poor decision of the shell is inescapable, and that is the lack of consideration of users of assistive tech.</p><p>It's impossible at this point to retrofit the terminal with some sort of compatibility layer for assistive tech. Modern UIs think in terms of hierarchy; you have boxes inside boxes, text inside panels inside views. Terminal UI is flat, even hacky; you have to lay out everything yourself. Modern terminal text editors have fair amounts of code to calculate the width of text, because monospace isn't truly monospace – find out how much space that escape sequence will take, or that composed emoji, or even distinguish between Latin (single-width) and CJK (double-width) characters.</p><p>This is all already written code. UI frameworks have figured out text layout for developers years ago. Terminal programs have to rewrite all of that, and each program has its own bespoke layout system, utterly innavegable labyrinths of abstractions. Assistive technology cannot dream to understand it all, especially when all it's exposed to is the control codes that tell the cursor to move back and forth to print data.</p><h2><a class=page-anchor id=conclusion></a>Conclusion</h2><p>Phew, that was a long one! So, how can things truly be improved?</p><p>For one, I would suggest to adopt the model of the notebook. The notebook and shell are fundamentally similar in a lot of ways – you enter code, then it gives you a reply. Rinse, repeat, ad nauseum. However, the notebook takes full advantage of graphical interfaces. Initially, this was designed to give mathematical programming languages like Wolfram and Julia an edge, being able to display complex graphs and mathematical notation seamlessly.</p><p>However, I believe that the same principles could be adapted to the terminal. Obviously, it wouldn't operate the same as the notebook – the terminal should still prioritize being able to enter code quickly rather than create a readable document out of a shell session. Similarly, pipeline programming and live output are still hugely useful tools and intuitive mental models, and programs should be able to instate their own prompts, etc.; rather than notebook functions, which only have a single return value like in most programming languages.</p><p>Atop that, I believe that graphical layout programs should be exported into separate windows. Applications should open graphical windows if they need it, rather than trying to cram everything into a single, convoluted interface.</p><p>With these changes, I believe that the shell could become a truly useful window into the insides of modern computers – desktops, servers, embedded devices, etc.. Right now, the ubiquitous standards (POSIX et al.) have some egregious flaws that make it frustrating to newcomers and folks with disabilities, but I believe that a fundamental overhaul can turn the same principle around into a truly incredible, intuitive environment.</p><hr><h2>Comments</h2><p>Tell me what I got right or wrong! Did this help you? Do you have any other questions or concerns? I'm all (elf) ears.</p><script src=https://utteranc.es/client.js repo=eunakria/eunakria.github.io issue-term=og:title theme=github-light crossorigin=anonymous async></script></div><div class=grey-bg><div class=container><footer><p class=copyright>© 2021 Linus Parker</p><div class=footer-grid><div><p>See this page in another language:</p><p class=select><select id=lang-select><option value=en selected=selected>English</option><option value=es>español</option></select></p></div><div><p>Helpful links:</p><ul><li><a href=https://github.com/eunakria/eunakria.github.io/ >Check out the page source</a></li><li><a href=/ >Go back home</a></li></ul></div></div></footer></div></div></body></html>